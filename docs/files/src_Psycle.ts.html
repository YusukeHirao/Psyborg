<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>src/Psycle.ts - Psyborg</title>
	<link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
	<link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
	<script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<header id="header">
	<h1>Psyborg</h1>
	<span class="version">0.3.3</span>
	
</header>

<div id="api-options">
	<input type="checkbox" id="api-show-inherited" checked><label for="api-show-inherited">継承</label>
	<input type="checkbox" id="api-show-protected" checked><label for="api-show-protected">プロテクト</label>
	<input type="checkbox" id="api-show-private" checked><label for="api-show-private">プライベート</label>
	<input type="checkbox" id="api-show-deprecated" checked><label for="api-show-deprecated">非推奨</label>
</div>



<div>
	<main>
		<section id="docs-main">
			<h1 class="file-heading">File: src/Psycle.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**!
 * スライド要素を生成・管理するクラス
 *
 * @class Psycle
 * @since 0.1.0
 * @extends PsyborgElement
 * @constructor
 * @param {jQuery} $el インスタンス化する要素
 * @param {any} options
 * @param {number} [options.startIndex=0] 最初に表示するパネル番号
 * @param {string} [options.transition=&#x27;slide&#x27;] トランジションの種類
 * @param {number} [options.duration=600] アニメーション時間
 * @param {string} [options.easing=&#x27;swing&#x27;] トランジションのイージング
 * @param {number} [options.delay=3000] オートプレイの時の待機時間
 * @param {boolean} [options.auto=true] オートプレイかどうか
 * @param {boolean} [options.cancel=true] アニメーション中にキャンセル可能かどうか（アニメーション中にパネル選択やパネル送りを上書きできるかどうか）
 * @param {any} [options.repeat=PsycleRepeat.RETURN] 繰り返しの種類(NONE: 繰り返ししない, RETURN: 最後まで到達すると最初に戻る, LOOP: ループしてるかのように最初に戻る（ループに対応しているトランジションのみ））
 * @param {string} [options.container=&#x27;&gt;ul:eq(0)&#x27;] コンテナを取得するためのセレクタ
 * @param {string} [options.panels=&#x27;&gt;li&#x27;] パネルを取得するためのセレクタ（コンテナからのパス）
 * @param {string} [options.currentClass=&#x27;current&#x27;] 現在のパネルに設定されるクラス名
 * @param {string} [options.delayWhenFire=0] 遷移処理が発生する(&#x60;before&#x60;関数から&#x60;fire&#x60;関数)までの遅延時間(ミリ秒)
 * @param {number} [options.clone=2] ループリピートにしたときの各要素に対してのクローン要素の数
 * @param {number} [options.cols=1] カラム(列)の数（カラム対応のトランジションのみ）
 * @param {number} [options.rows=1] 行の数（行対応のトランジションのみ）
 * @param {number} [options.offsetX=0] コンテナの横方向のオフセット（コンテナが平行移動するトランジションのみ）
 * @param {number} [options.offsetY=0] コンテナの縦方向のオフセット（コンテナが平行移動するトランジションのみ）
 * @param {boolean} [options.nearby=false] ???
 * @param {boolean} [options.innerFocus=false] マルチカラムの時のフォーカスの当たり方が内側優先かどうか、noFocusがtrueの場合は無効
 * @param {boolean} [options.noFocus=true] マルチカラムの時、パネルにフォーカスを当てない、また、indexは先頭の要素だけを指すことになる
 * @param {boolean} [options.resizable=false] リサイズによってパネルの大きさが変わる場合はtrueを渡す
 * @param {boolean} [options.bindKeyboard=false] キーボードで操作できるようにするかどうか
 * @param {any} [options.showOnlyOnce=null] オートプレイの時に一度しか表示しないパネルのフィルタセレクタ (例) .once
 * @param {any} [options.controller=null] コントローラ
 * @param {any} [options.marker=null] マーカー
 * @param {any} [options.thumbnail=null] サムネイル
 * @param {boolean} [options.css3=true] ???
 * @param {number} [options.loopCloneLength=null] ループ時のスライド専用 クローンをいくつつくるか
 * @param {Function[]} [options.scenes=[]] ???
 */
class Psycle extends PsyborgElement {

	constructor ($el:JQuery, options:any) {
		super($el);
		var defaults:IPsycleConfig = {
			startIndex:&lt;number&gt; 0,
			transition:&lt;string&gt; &#x27;slide&#x27;,
			duration:&lt;number&gt; 600,
			easing:&lt;string&gt; &#x27;swing&#x27;,
			delay:&lt;number&gt; 3000,
			auto:&lt;boolean&gt; true,
			cancel:&lt;boolean&gt; true,
			repeat:&lt;any&gt; PsycleRepeat.RETURN,
			container:&lt;string&gt; &#x27;&gt;ul:eq(0)&#x27;,
			panels:&lt;string&gt; &#x27;&gt;li&#x27;,
			currentClass:&lt;string&gt; &#x27;current&#x27;,
			delayWhenFire:&lt;number&gt; 0,
			clone:&lt;number&gt; 0,
			cols:&lt;number&gt; 1,
			rows:&lt;number&gt; 1,
			offsetX:&lt;number&gt; 0,
			offsetY:&lt;number&gt; 0,
			nearby:&lt;boolean&gt; false,
			innerFocus:&lt;boolean&gt; false,
			noFocus:&lt;boolean&gt; true,
			resizable:&lt;boolean&gt; false,
			bindKeyboard:&lt;boolean&gt; false,
			showOnlyOnce:&lt;any&gt; null,
			controller:&lt;any&gt; null,
			marker:&lt;any&gt; null,
			thumbnail:&lt;any&gt; null,
			css3:&lt;boolean&gt; true,
			loopCloneLength:&lt;number&gt; null,
			scenes:&lt;Function[]&gt; []
		};
		this._config = &lt;IPsycleConfig&gt;$.extend(defaults, options);

		// 要素インスタンス
		var $stage = $el;
		var $container = $stage.find(this._config.container);
		var $panels = $container.find(this._config.panels);
		this.stage = new PsycleStage($stage);
		this.container = new PsycleContainer($container);
		this.panels = new PsyclePanelList($panels);
		this.transition = PsycleTransition.transitions[this._config.transition];

		if (this.transition == null) {
			throw new ReferenceError(&quot;&#x27;&quot; + this._config.transition + &quot;&#x27; is not transition type&quot;);
		}

		// オプションの継承
		this.index = this._config.startIndex;
		this.repeat = this._config.repeat;

		// プロパティ算出
		this.length = this.panels.length;
		this.progressIndex = this.index;

		// イベントの登録
		this._resizeable();

		// 処理開始
		this._init();
		this._silent();

		// 自動再生
		if (this._config.auto) {
			this.play();
		}

		// 自身のインスタンスを登録
		$el.data(&#x27;psycle&#x27;, this);
	}

	/**!
	 * 現在表示しているパネル番号
	 *
	 * @property index
	 * @since 0.1.0
	 * @public
	 * @type number
	 * @default 0
	 */
	public index:number = 0;

	/**!
	 * 内部的に制御する遷移先を管理するパネル番号
	 *
	 * @property progressIndex
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public progressIndex:number;

	/**!
	 * 設定されているトランジションオブジェクト
	 *
	 * @property transition
	 * @since 0.1.0
	 * @public
	 * @type PsycleTransition
	 */
	public transition:PsycleTransition;

	/**!
	 * スライドショーステージ要素
	 *
	 * @property stage
	 * @since 0.1.0
	 * @public
	 * @type PsycleStage
	 */
	public stage:PsycleStage;

	/**!
	 * スライドショーコンテナ要素
	 *
	 * @property container
	 * @since 0.1.0
	 * @public
	 * @type PsycleContainer
	 */
	public container:PsycleContainer;

	/**!
	 * スライドショーパネル要素リスト
	 *
	 * @property panels
	 * @since 0.1.0
	 * @public
	 * @type PsyclePanelList
	 */
	public panels:PsyclePanelList;

	/**!
	 * 自動再生タイマー
	 *
	 * @property timer
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public timer:number;

	/**!
	 * ステージの幅
	 *
	 * @property stageWidth
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public stageWidth:number;

	/**!
	 * パネル個々の幅
	 *
	 * @property panelWidth
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public panelWidth:number;

	/**!
	 * パネルの数
	 *
	 * @property length
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public length:number;

	/**!
	 * 遷移前のパネル番号
	 *
	 * @property from
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public from:number;

	/**!
	 * 遷移後のパネル番号
	 *
	 * @property to
	 * @since 0.1.0
	 * @public
	 * @type number
	 */
	public to:number;

	/**!
	 * 前に遷移するか次に遷移するか 番号の変化量
	 *
	 * @property vector
	 * @since 0.1.0
	 * @public
	 * @type number
	 * @default 0
	 */
	public vector:number = 0;

	/**!
	 * 現在遷移状態かどうか
	 *
	 * @property isTransition
	 * @since 0.1.0
	 * @public
	 * @type boolean
	 * @default false
	 */
	public isTransition:boolean = false;

	/**!
	 * 遷移アニメーションを制御する&#x60;jQueryAnimation&#x60;インスタンス
	 *
	 * @property animation
	 * @since 0.1.0
	 * @public
	 * @type jQueryAnimation
	 */
	public animation:any;

	/**!
	 * リピート方法
	 *
	 * @property repeat
	 * @since 0.3.0
	 * @public
	 * @type PsycleRepeat
	 */
	public repeat:PsycleRepeat;

	/**!
	 * 自動再生の一時停止状態かどうか
	 *
	 * @property isPaused
	 * @since 0.1.0
	 * @public
	 * @type boolean
	 * @default false
	 */
	public isPaused:boolean = false;

	/**!
	 * オプション
	 *
	 * @property _config
	 * @since 0.1.0
	 * @private
	 * @type IPsycleConfig
	 */
	private _config:IPsycleConfig;

	/**!
	 * 自動再生を開始する
	 *
	 * @method play
	 * @since 0.1.0
	 * @public
	 * @return {Psycle} 自身のインスタンス
	 */
	public play ():Psycle {
		var defaultPrevented:boolean = this.trigger(&#x27;play&#x27;);
		if (defaultPrevented) {
			this.timer = setTimeout(() =&gt; {
				this.next();
			}, this._config.delay);
		}
		return this;
	}

	/**!
	 * 自動再生を停止する
	 *
	 * @method stop
	 * @since 0.1.0
	 * @public
	 * @return {Psycle} 自身のインスタンス
	 */
	public stop ():Psycle {
		clearTimeout(this.timer);
		return this;
	}

	/**!
	 * 指定の番号のパネルへ遷移する
	 *
	 * @method gotoPanel
	 * @since 0.1.0
	 * @public
	 * @param {number} to 遷移させるパネル番号
	 * @return {Psycle} 自身のインスタンス
	 */
	public gotoPanel (to:number):Psycle {
		if (this.isTransition) {
			return this;
		}
		var optTo:number = this._optimizeCounter(to);
		if (optTo === this.index) {
			return this;
		}
		this.vector = this._optimizeVector(optTo);
		this.stop();
		this.isPaused = false;
		this.from = this.index;
		this.to = optTo;
		this.progressIndex = to;
		this._before();
		setTimeout(() =&gt; {
			this.isTransition = true;
			this._fire();
			// アニメーションが完了したとき
			this.animation.done(() =&gt; {
				this._done();
			});
			// アニメーションが強制的にストップしたとき
			this.animation.fail(() =&gt; {
				this._fail();
			});
		}, this._config.delayWhenFire);
		return this;
	}

	/**!
	 * 前のパネルへ遷移する
	 *
	 * @method prev
	 * @since 0.1.0
	 * @public
	 * @return {Psycle} 自身のインスタンス
	 */
	public prev ():Psycle {
		if (this.isTransition) {
			return this;
		}
		this.gotoPanel(this.index - 1);
		return this;
	}

	/**!
	 * 次のパネルへ遷移する
	 *
	 * @method next
	 * @since 0.1.0
	 * @public
	 * @return {Psycle} 自身のインスタンス
	 */
	public next ():Psycle {
		if (this.isTransition) {
			return this;
		}
		this.gotoPanel(this.index + 1);
		return this;
	}

	/**!
	 * マーカーを生成する
	 *
	 * @method marker
	 * @since 0.3.0
	 * @public
	 * @return {JQuery} 生成したjQuery要素
	 */
	public marker():JQuery {
		var _this:Psycle = this;
		var $ul:JQuery = $(&#x27;&lt;ul /&gt;&#x27;);
		var $li:JQuery;
		var i:number = 0;
		var l:number = this.length;
		for (; i &lt; l; i++) {
			$li = $(&#x27;&lt;li /&gt;&#x27;);
			$li.appendTo($ul);
		}
		var $lis = $ul.find(&#x27;li&#x27;);
		this.on(PsycleEvent.PANEL_CHANGE_END, (e:PsyborgEvent) =&gt; {
			$lis.removeClass(this._config.currentClass);
			$lis.eq(e.data.index).addClass(this._config.currentClass);
		});
		$lis.eq(this._config.startIndex).addClass(this._config.currentClass);
		$lis.on(&#x27;click&#x27;, function () {
			_this.gotoPanel($(this).index());
		});
		return $ul;
	}

	/**!
	 * 番号の変化量の正規化
	 *
	 * @method _optimizeVector
	 * @since 0.3.0
	 * @private
	 * @param {number} to 目的のパネル番号
	 * @return {number} 正規化された変化量
	 */
	private _optimizeVector (to:number):number {
		var vector:number;
		var dist:number = Math.abs(this.index - to);
		if (this.repeat === PsycleRepeat.LOOP) {
			var negativeTo:number = to - this.length;
			var positiveTo:number = to + this.length;
			var negativeDist:number = Math.abs(this.index - negativeTo);
			var positiveDist:number = Math.abs(this.index - positiveTo);
			// 一番小さい値の時の結果をハッシュに登録 キーを利用した条件分岐
			var hash:any = {};
			hash[negativeDist] = -1;
			hash[positiveDist] = 1;
			hash[dist] = (this.index &lt; to) ? 1 : -1;
			var minDist:number = Math.min(dist, positiveDist, negativeDist);
			vector = hash[minDist] * minDist;
		} else {
			vector = dist * ((this.index &lt; to) ? 1 : -1);
		}
		return vector;
	}

	/**!
	 * パネル番号の正規化
	 *
	 * @method _optimizeCounter
	 * @since 0.1.0
	 * @private
	 * @param {number} index 正規化するパネル番号
	 * @return {number} 正規化されたパネル番号
	 */
	private _optimizeCounter (index:number):number {
		var maxIndex:number = this.length - 1;
		var optIndex:number;
		switch (this.repeat) {
			case PsycleRepeat.LOOP:
			case PsycleRepeat.RETURN:
				optIndex = (index &lt; 0) ? (maxIndex + (index % maxIndex) + 1) : index;
				optIndex = (optIndex &lt; maxIndex) ? optIndex : (optIndex % (maxIndex + 1));
				break;
			default:
				optIndex = (index &lt; 0) ? 0 : index;
				optIndex = (optIndex &lt; maxIndex) ? optIndex : maxIndex;
				if (this._isFirst(optIndex) || this._isLast(optIndex)) {
					this.stop();
				}
		}
		return optIndex;
	}

	/**!
	 * 指定したパネル番号が最初のパネルかどうか
	 *
	 * @method _isLast
	 * @since 0.3.0
	 * @private
	 * @param {number} index 評価するパネル番号
	 * @return {boolean} 最初のパネルなら&#x60;true&#x60;
	 */
	private _isFirst (index:number):boolean {
		return index === 0;
	}

	/**!
	 * 指定したパネル番号が最後のパネルかどうか
	 *
	 * @method _isLast
	 * @since 0.3.0
	 * @private
	 * @param {number} index 評価するパネル番号
	 * @return {boolean} 最後のパネルなら&#x60;true&#x60;
	 */
	private _isLast (index:number):boolean {
		return index === this.length - 1;
	}

	/**!
	 * リサイズイベントを関連付ける
	 *
	 * @method _resizeable
	 * @since 0.1.0
	 * @private
	 */
	private _resizeable ():void {
		var resizeEndDelay:number = 1200;
		var resizeTimer:number;
		var resizing:boolean = false;
		$(window).on(&#x27;resize&#x27;, (e:JQueryEventObject) =&gt; {
			if (!resizing) {
				resizing = true;
				this._resizeStart();
			}
			clearTimeout(resizeTimer);
			this._resize();
			resizeTimer = setTimeout(() =&gt; {
				this._resizeEnd();
				resizing = false;
			}, resizeEndDelay);
		});
	}

	/**!
	 * 現在の状態の情報を返す
	 *
	 * @method _getState
	 * @since 0.1.0
	 * @private
	 */
	private _getState ():IPsycleState {
		return &lt;IPsycleState&gt;{
			index:&lt;number&gt; this.index,
			stage:&lt;PsycleStage&gt; this.stage,
			container:&lt;PsycleContainer&gt; this.container,
			panels:&lt;PsyclePanelList&gt; this.panels,
			stageWidth:&lt;number&gt; this.stageWidth,
			panelWidth:&lt;number&gt; this.panelWidth,
			length:&lt;number&gt; this.length,
			from:&lt;number&gt; this.from,
			to:&lt;number&gt; this.to,
			vector:&lt;number&gt; this.vector,
			isTransition:&lt;boolean&gt; this.isTransition,
			isPaused:&lt;boolean&gt; this.isPaused
		};
	}

	/**!
	 * 初期化処理を実行する
	 *
	 * @method _init
	 * @since 0.1.0
	 * @private
	 */
	private _init ():void {
		this.transition.init.call(this);
		this.transition.reflow.call(this, { timing: PsycleReflowTiming.INIT });
		this.trigger(PsycleEvent.INIT, this._getState());
	}

	/**!
	 * 非遷移番号移動を実行する
	 *
	 * @method _silent
	 * @since 0.1.0
	 * @private
	 */
	private _silent ():void {
		this.transition.silent.call(this);
		this.transition.reflow.call(this, { timing: PsycleReflowTiming.TRANSITION_END });
		this.panels.setCurrent(this.index, this._config.currentClass);
	}

	/**!
	 * 遷移直前の処理を実行する
	 *
	 * @method _before
	 * @since 0.1.0
	 * @private
	 */
	private _before ():void {
		this.transition.before.call(this);
		this.panels.resetCurrent(this._config.currentClass);
		this.trigger(PsycleEvent.PANEL_CHANGE_START, this._getState());
	}

	/**!
	 * 遷移時の処理を実行する
	 *
	 * @method _fire
	 * @since 0.1.0
	 * @private
	 */
	private _fire ():void {
		this.transition.fire.call(this);
	}

	/**!
	 * 遷移キャンセル時の処理を実行する
	 *
	 * @method _cancel
	 * @since 0.1.0
	 * @private
	 */
	private _cancel ():void {
		this.transition.cancel.call(this);
	}

	/**!
	 * 遷移完了時コールバック関数
	 *
	 * @method _done
	 * @since 0.1.0
	 * @private
	 */
	private _done ():void {
		this.index = this.to;
		this.isTransition = false;
		this._after();
		this._silent();
		this.trigger(PsycleEvent.PANEL_CHANGE_END, this._getState());
		// 自動再生状態なら再生開始する
		if (this._config.auto) {
			this.play();
		}
	}

	/**!
	 * 遷移後の処理を実行する
	 *
	 * @method _after
	 * @since 0.1.0
	 * @private
	 */
	private _after ():void {
		this.transition.after.call(this);
	}

	/**!
	 * 遷移未完了で停止した場合のコールバック関数
	 *
	 * @method _fail
	 * @since 0.1.0
	 * @private
	 */
	private _fail ():void {
		this.stop();
		this._cancel();
		this.isPaused = true;
		this.trigger(PsycleEvent.PANEL_CHANGE_CANCEL, this._getState());
	}

	/**!
	 * リサイズ中の処理を実行する
	 *
	 * @method _resize
	 * @since 0.1.0
	 * @private
	 */
	private _resize ():void {
		this.transition.reflow.call(this, { timing: PsycleReflowTiming.RESIZE });
	}

	/**!
	 * リサイズ開始時の処理を実行する
	 *
	 * @method _resizeStart
	 * @since 0.1.0
	 * @private
	 */
	private _resizeStart ():void {
		this.transition.reflow.call(this, { timing: PsycleReflowTiming.RESIZE_START });
		if (this.animation &amp;&amp; this.isTransition) {
			this.animation.stop();
			this.stop();
		}
	}

	/**!
	 * リサイズ終了時の処理を実行する
	 *
	 * @method _resizeEnd
	 * @since 0.1.0
	 * @private
	 */
	private _resizeEnd ():void {
		this.transition.reflow.call(this, { timing: PsycleReflowTiming.RESIZE_END });
		if (this.isPaused &amp;&amp; this.isTransition) {
			this.gotoPanel(this.to);
		}
	}

}


interface IPsycleConfig {
	startIndex:number;
	transition:string;
	duration:number;
	easing:string;
	delay:number;
	auto:boolean;
	delayWhenFire:number;
	cancel:boolean;
	repeat:any;
	container:string;
	panels:string;
	currentClass:string;
	clone: number;
	cols:number;
	rows:number;
	offsetX:number;
	offsetY:number;
	nearby:boolean;
	innerFocus:boolean;
	noFocus:boolean;
	resizable:boolean;
	bindKeyboard:boolean;
	showOnlyOnce:string;
	controller:any;
	marker:any;
	thumbnail:any;
	css3:boolean;
	loopCloneLength:number;
	scenes:Function[];
}

interface IPsycleState {
	index:number;
	stage:PsycleStage;
	container:PsycleContainer;
	panels:PsyclePanelList;
	stageWidth:number;
	panelWidth:number;
	length:number;
	from:number;
	to:number;
	vector:number;
	isTransition:boolean;
	isPaused:boolean;
}

    </pre>
</div>

		</section>
	</main>
	<section id="docs-sidebar">
		<nav id="api-list">
	<h1>API</h1>
	<div id="api-tabview" class="tabview">
		<ul class="tabs">
			<li><a href="#api-classes">クラス</a></li>
		</ul>
		<div id="api-tabview-filter">
			<input type="search" id="api-filter" placeholder="クラスを検索">
		</div>
		<div id="api-tabview-panel">
			<ul id="api-classes" class="apis classes">
				
				<li><a href="../classes/jQuery.html">jQuery</a></li>
				
				<li><a href="../classes/PsyborgCSS.html">PsyborgCSS</a></li>
				
				<li><a href="../classes/PsyborgElement.html">PsyborgElement</a></li>
				
				<li><a href="../classes/PsyborgEvent.html">PsyborgEvent</a></li>
				
				<li><a href="../classes/PsyborgEventDispacther.html">PsyborgEventDispacther</a></li>
				
				<li><a href="../classes/Psycle.html">Psycle</a></li>
				
				<li><a href="../classes/PsycleContainer.html">PsycleContainer</a></li>
				
				<li><a href="../classes/PsyclePanel.html">PsyclePanel</a></li>
				
				<li><a href="../classes/PsyclePanelList.html">PsyclePanelList</a></li>
				
				<li><a href="../classes/PsycleStage.html">PsycleStage</a></li>
				
				<li><a href="../classes/PsycleTransition.html">PsycleTransition</a></li>
				
			</ul>
			<ul id="api-modules" class="apis modules">
				
			</ul>
		</div>
	</div>
</nav>


	</section>
</div>

<footer id="footer">
	<dl>
		<dt>name</dt>
		<dd>Psyborg</dd>
		<dt>version</dt>
		<dd>0.3.3</dd>
		<dt>author</dt>
		<dd>YusukeHirao</dd>
		<dt>licenses</dt>
		<dd><a href="https://github.com/YusukeHirao/blockdown/blob/master/LICENSE">MIT</a></dd>
		<dt>repository</dt>
		<dd><a href="https://github.com/YusukeHirao/blockdown">https://github.com/YusukeHirao/blockdown</a></dd>
	</dl>
</footer>

<a href="https://github.com/YusukeHirao/blockdown"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>

</body>
</html>
