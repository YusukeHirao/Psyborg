<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/psyborg/Psycle/Psycle.ts - Psyborg</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Psyborg"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.3beta</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/PsyborgElement.html">PsyborgElement</a></li>
            
                <li><a href="../classes/PsyborgEvent.html">PsyborgEvent</a></li>
            
                <li><a href="../classes/PsyborgEventDispacther.html">PsyborgEventDispacther</a></li>
            
                <li><a href="../classes/Psycle.html">Psycle</a></li>
            
                <li><a href="../classes/PsycleContainer.html">PsycleContainer</a></li>
            
                <li><a href="../classes/PsyclePanel.html">PsyclePanel</a></li>
            
                <li><a href="../classes/PsyclePanelList.html">PsyclePanelList</a></li>
            
                <li><a href="../classes/PsycleStage.html">PsycleStage</a></li>
            
                <li><a href="../classes/PsycleTransition.html">PsycleTransition</a></li>
            
                <li><a href="../classes/StyleSheet.html">StyleSheet</a></li>
            
                <li><a href="../classes/Util.html">Util</a></li>
            
                <li><a href="../classes/Window.html">Window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/psyborg.html">psyborg</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/psyborg/Psycle/Psycle.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
module psyborg {
	/**!
	 * スライド要素を生成・管理するクラス
	 *
	 * @class Psycle
	 * @since 0.1.0
	 * @extends PsyborgElement
	 * @constructor
	 * @param {jQuery} $el インスタンス化する要素
	 * @param {any} options
	 * @param {string} [options.instanceKey=&#x27;psycle&#x27;] &#x60;data&#x60;メソッドで取得できるインスタンスのキー文字列
	 * @param {number} [options.startIndex=0] 最初に表示するパネル番号
	 * @param {string} [options.transition=&#x27;slide&#x27;] トランジションの種類
	 * @param {number} [options.duration=600] アニメーション時間
	 * @param {string} [options.easing=&#x27;swing&#x27;] トランジションのイージング
	 * @param {number} [options.delay=3000] オートプレイの時の待機時間
	 * @param {boolean} [options.auto=true] オートプレイかどうか
	 * @param {boolean} [options.cancel=true] アニメーション中にキャンセル可能かどうか（アニメーション中にパネル選択やパネル送りを上書きできるかどうか）
	 * @param {any} [options.repeat=PsycleRepeat.RETURN] 繰り返しの種類(NONE: 繰り返ししない, RETURN: 最後まで到達すると最初に戻る, LOOP: ループしてるかのように最初に戻る（ループに対応しているトランジションのみ））
	 * @param {string} [options.container=&#x27;&gt;ul:eq(0)&#x27;] コンテナを取得するためのセレクタ
	 * @param {string} [options.panels=&#x27;&gt;li&#x27;] パネルを取得するためのセレクタ（コンテナからのパス）
	 * @param {string} [options.currentClass=&#x27;current&#x27;] 現在のパネルに設定されるクラス名
	 * @param {string} [options.delayWhenFire=0] 遷移処理が発生する(&#x60;before&#x60;関数から&#x60;fire&#x60;関数)までの遅延時間(ミリ秒)
	 * @param {number} [options.clone=2] ループリピートにしたときの各要素に対してのクローン要素の数
	 * @param {number} [options.cols=1] カラム(列)の数（カラム対応のトランジションのみ）
	 * @param {number} [options.rows=1] 行の数（行対応のトランジションのみ）
	 * @param {number} [options.offsetX=0] コンテナの横方向のオフセット（コンテナが平行移動するトランジションのみ）
	 * @param {number} [options.offsetY=0] コンテナの縦方向のオフセット（コンテナが平行移動するトランジションのみ）
	 * @param {boolean} [options.nearby=false] ???
	 * @param {boolean} [options.innerFocus=false] マルチカラムの時のフォーカスの当たり方が内側優先かどうか、noFocusがtrueの場合は無効
	 * @param {boolean} [options.noFocus=true] マルチカラムの時、パネルにフォーカスを当てない、また、indexは先頭の要素だけを指すことになる
	 * @param {boolean} [options.resizable=false] リサイズによってパネルの大きさが変わる場合はtrueを渡す
	 * @param {boolean} [options.draggable=false] ドラッグによって遷移をコントロールさせる場合はtrueを渡す
	 * @param {boolean} [options.swipeable=false] スワイプによって遷移をコントロールさせる場合はtrueを渡す
	 * @param {boolean} [options.dragBlockVertical=false] ドラッグの上下を抑制させる(タッチデバイスのスクロールも抑制される)場合はtrueを渡す
	 * @param {boolean} [options.bindKeyboard=false] キーボードで操作できるようにするかどうか
	 * @param {any} [options.showOnlyOnce=null] オートプレイの時に一度しか表示しないパネルのフィルタセレクタ (例) .once
	 * @param {any} [options.controller=null] コントローラ
	 * @param {any} [options.marker=null] マーカー
	 * @param {any} [options.thumbnail=null] サムネイル
	 * @param {boolean} [options.css3=true] ???
	 * @param {number} [options.loopCloneLength=null] ループ時のスライド専用 クローンをいくつつくるか
	 * @param {Function[]} [options.scenes=[]] ???
	 */
	export class Psycle extends PsyborgElement {

		constructor ($el:JQuery, options:any) {
			super($el);
			var defaults:IPsycleConfig = {
				instanceKey:&lt;string&gt; &#x27;psycle&#x27;,
				startIndex:&lt;number&gt; 0,
				transition:&lt;string&gt; &#x27;slide&#x27;,
				duration:&lt;number&gt; 600,
				easing:&lt;string&gt; &#x27;swing&#x27;,
				delay:&lt;number&gt; 3000,
				auto:&lt;boolean&gt; true,
				cancel:&lt;boolean&gt; true,
				repeat:&lt;any&gt; PsycleRepeat.RETURN,
				container:&lt;string&gt; &#x27;&gt;ul:eq(0)&#x27;,
				panels:&lt;string&gt; &#x27;&gt;li&#x27;,
				currentClass:&lt;string&gt; &#x27;current&#x27;,
				delayWhenFire:&lt;number&gt; 0,
				clone:&lt;number&gt; 2,
				cols:&lt;number&gt; 1,
				rows:&lt;number&gt; 1,
				offsetX:&lt;number&gt; 0,
				offsetY:&lt;number&gt; 0,
				nearby:&lt;boolean&gt; false,
				innerFocus:&lt;boolean&gt; false,
				noFocus:&lt;boolean&gt; true,
				resizable:&lt;boolean&gt; false,
				draggable:&lt;boolean&gt; false,
				swipeable:&lt;boolean&gt; false,
				dragBlockVertical:&lt;boolean&gt; false,
				bindKeyboard:&lt;boolean&gt; false,
				showOnlyOnce:&lt;any&gt; null,
				controller:&lt;any&gt; null,
				marker:&lt;any&gt; null,
				thumbnail:&lt;any&gt; null,
				css3:&lt;boolean&gt; true,
				loopCloneLength:&lt;number&gt; null,
				scenes:&lt;Function[]&gt; []
			};
			this._config = &lt;IPsycleConfig&gt;$.extend(defaults, options);

			// 要素インスタンス
			var $stage = $el;
			var $container = $stage.find(this._config.container);
			var $panels = $container.find(this._config.panels);
			this.panels = new PsyclePanelList($panels);
			this.container = new PsycleContainer($container);
			this.stage = new PsycleStage($stage, this.panels);
			this.transition = PsycleTransition.transitions[this._config.transition];

			if (this.transition == null) {
				throw new ReferenceError(&quot;&#x27;&quot; + this._config.transition + &quot;&#x27; is not transition type&quot;);
			}

			if (this._config.draggable || this._config.swipeable) {
				if (!(jQuery.fn.hammer || Hammer)) {
					throw new ReferenceError(&#x27;&quot;Hammer.js&quot; is required when use &quot;draggable&quot; or &quot;swipeable&quot; options.&#x27;);
				}
			}

			// オプションの継承
			this.index = +this._config.startIndex || 0;
			this.to = this.index;
			this.from = this.index;
			this.repeat = (&#x27;&#x27; + this._config.repeat).toLowerCase();

			// プロパティ算出
			this.length = this.panels.length;
			this.progressIndex = this.index;

			// イベントの登録
			this._resizeable();

			// 処理開始
			this._init();
			this._silent();

			// 自動再生
			if (this._config.auto) {
				this.play();
			}

			// パネル内の画像が読み込まれたとき
			this.panels.on(&#x27;load&#x27;, () =&gt; {
				this._load();
			});

			// 自身のインスタンスを登録
			$el.data(this._config.instanceKey, this);
		}

		/**!
		 * 現在表示しているパネル番号
		 *
		 * @property index
		 * @since 0.1.0
		 * @public
		 * @type number
		 * @default 0
		 */
		public index:number = 0;

		/**!
		 * 内部的に制御する遷移先を管理するパネル番号
		 *
		 * @property progressIndex
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public progressIndex:number;

		/**!
		 * 設定されているトランジションオブジェクト
		 *
		 * @property transition
		 * @since 0.1.0
		 * @public
		 * @type PsycleTransition
		 */
		public transition:PsycleTransition;

		/**!
		 * スライドショーステージ要素
		 *
		 * @property stage
		 * @since 0.1.0
		 * @public
		 * @type PsycleStage
		 */
		public stage:PsycleStage;

		/**!
		 * スライドショーコンテナ要素
		 *
		 * @property container
		 * @since 0.1.0
		 * @public
		 * @type PsycleContainer
		 */
		public container:PsycleContainer;

		/**!
		 * スライドショーパネル要素リスト
		 *
		 * @property panels
		 * @since 0.1.0
		 * @public
		 * @type PsyclePanelList
		 */
		public panels:PsyclePanelList;

		/**!
		 * 自動再生タイマー
		 *
		 * @property timer
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public timer:number;

		/**!
		 * ステージの幅
		 *
		 * @property stageWidth
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public stageWidth:number;

		/**!
		 * パネル個々の幅
		 *
		 * @property panelWidth
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public panelWidth:number;

		/**!
		 * パネルの数
		 *
		 * @property length
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public length:number;

		/**!
		 * 遷移前のパネル番号
		 *
		 * @property from
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public from:number;

		/**!
		 * 遷移後のパネル番号
		 *
		 * @property to
		 * @since 0.1.0
		 * @public
		 * @type number
		 */
		public to:number;

		/**!
		 * 前に遷移するか次に遷移するか 番号の変化量
		 *
		 * @property vector
		 * @since 0.1.0
		 * @public
		 * @type number
		 * @default 0
		 */
		public vector:number = 0;

		/**!
		 * 現在遷移状態かどうか
		 *
		 * @property isTransition
		 * @since 0.1.0
		 * @public
		 * @type boolean
		 * @default false
		 */
		public isTransition:boolean = false;

		/**!
		 * 遷移アニメーションを制御する&#x60;jQueryAnimation&#x60;インスタンス
		 *
		 * @property animation
		 * @since 0.1.0
		 * @public
		 * @type jQueryAnimation
		 */
		public animation:any;

		/**!
		 * リピート方法
		 *
		 * @property repeat
		 * @since 0.3.0
		 * @public
		 * @type PsycleRepeat
		 */
		public repeat:PsycleRepeat;

		/**!
		 * 自動再生の一時停止状態かどうか
		 *
		 * @property isPaused
		 * @since 0.1.0
		 * @public
		 * @type boolean
		 * @default false
		 */
		public isPaused:boolean = false;

		/**!
		 * 現在のクローンパネルの数
		 *
		 * @property cloneCount
		 * @since 0.5.3
		 * @public
		 * @type number
		 * @default 0
		 */
		public cloneCount:number = 0;

		/**!
		 * オプション
		 *
		 * @property _config
		 * @since 0.1.0
		 * @private
		 * @type IPsycleConfig
		 */
		private _config:IPsycleConfig;

		/**!
		 * 今回処理する遷移の継続時間
		 *
		 * @property duration
		 * @deprecated
		 * @since 0.3.4
		 * @private
		 * @type number
		 */
		private _duration:number;

		/**!
		 * 今回処理する遷移の継続時間
		 *
		 * @property duration
		 * @since 0.6.0
		 * @public
		 * @type number
		 */
		public duration:number;

		/**!
		 * 遅延処理時の内部タイマー(setTimeoutの管理ID)
		 *
		 * @property _delayTimer
		 * @since 0.4.3
		 * @private
		 * @type number
		 */
		private _delayTimer:number;

		/**!
		 * 自動再生を開始する
		 *
		 * @method play
		 * @since 0.1.0
		 * @public
		 * @return {Psycle} 自身のインスタンス
		 */
		public play ():Psycle {
			var defaultPrevented:boolean = this.trigger(&#x27;play&#x27;);
			if (defaultPrevented) {
				clearTimeout(this.timer);
				this.timer = setTimeout(() =&gt; {
					this.next();
				}, this._config.delay);
			}
			return this;
		}

		/**!
		 * 自動再生を停止する
		 *
		 * @method stop
		 * @since 0.1.0
		 * @public
		 * @return {Psycle} 自身のインスタンス
		 */
		public stop ():Psycle {
			clearTimeout(this.timer);
			this.isPaused = true;
			return this;
		}

		/**!
		 * 遷移を強制的に停止する
		 * 遷移中のスタイルで固定される
		 *
		 * @method freeze
		 * @since 0.3.4
		 * @public
		 * @return {Psycle} 自身のインスタンス
		 */
		public freeze ():Psycle {
			if (this.animation) {
				this.animation.stop();
			}
			return this;
		}

		/**!
		 * 指定の番号のパネルへ遷移する
		 *
		 * @method gotoPanel
		 * @since 0.1.0
		 * @public
		 * @param {number} to 遷移させるパネル番号
		 * @param {number} [duration] 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @return {Psycle} 自身のインスタンス
		 */
		public gotoPanel (to:number, duration?:number, direction:number = 0):Psycle {
			if (this.isTransition) {
				return this;
			}
			if (this._config.delayWhenFire) {
				clearTimeout(this._delayTimer);
				this._delayTimer = setTimeout(() =&gt; {
					this._transitionTo(to, duration, direction);
				}, this._config.delayWhenFire);
			} else {
				this._transitionTo(to, duration, direction);
			}
			return this;
		}

		/**!
		 * 【廃止予定】パネル番号を設定する
		 *
		 * @method setIndex
		 * @deprecated
		 * @since 0.3.4
		 * @public
		 * @param {number} index 設定するインデックス番号
		 * @param {boolean} [overwriteCurrentIndex=true] 管理インデックス番号を上書きするかどうか
		 * @param {boolean} force 強制的に行うかどうか
		 * @return {boolean} 変化があったかどうか
		 */
		public setIndex (index:number, overwriteCurrentIndex:boolean = true, force:boolean = false):boolean {
			var optTo:number = this._optimizeCounter(index);
			if (!force &amp;&amp; optTo === this.index) {
				return false;
			}
			this.vector = this._optimizeVector(optTo);
			this.stop();
			this.from = this.index;
			this.to = optTo;
			this.progressIndex = index;
			if (overwriteCurrentIndex) {
				this.index = optTo;
			}
			return true;
		}

		/**!
		 * 前のパネルへ遷移する
		 *
		 * @method prev
		 * @since 0.1.0
		 * @public
		 * @param {number} [duration] 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @return {Psycle} 自身のインスタンス
		 */
		public prev (duration?:number):Psycle {
			if (this.isTransition) {
				return this;
			}
			this.gotoPanel(this.index - 1, duration, -1);
			return this;
		}

		/**!
		 * 次のパネルへ遷移する
		 *
		 * @method next
		 * @since 0.1.0
		 * @public
		 * @param {number} [duration] 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @return {Psycle} 自身のインスタンス
		 */
		public next (duration?:number):Psycle {
			if (this.isTransition) {
				return this;
			}
			this.gotoPanel(this.index + 1, duration, +1);
			return this;
		}

		/**!
		 * リフロー処理を実行する
		 *
		 * @method reflow
		 * @since 0.3.4
		 * @public
		 * @param {any} data リフロー処理時に渡す任意のデータ
		 * @return {Psycle} 自身のインスタンス
		 */
		public reflow (data?:any):Psycle {
			this.transition.reflow.call(this, {
				timing: PsycleReflowTiming.REFLOW_METHOD,
				data: data
			});
			return this;
		}

		/**!
		 * 現在のパネルが最初のパネルかどうか
		 *
		 * @method isFirst
		 * @since 0.4.0
		 * @public
		 * @return {boolean} 最初のパネルなら&#x60;true&#x60;
		 */
		public isFirst ():boolean {
			return this._isFirst(this.index);
		}

		/**!
		 * 現在のパネルが最後のパネルかどうか
		 *
		 * @method isLast
		 * @since 0.4.0
		 * @public
		 * @return {boolean} 最後のパネルなら&#x60;true&#x60;
		 */
		public isLast ():boolean {
			return this._isLast(this.index);
		}

		/**!
		 * マーカーを生成する
		 *
		 * @method marker
		 * @since 0.3.0
		 * @public
		 * @param {number} [duration] 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @return {JQuery} 生成したjQuery要素
		 */
		public marker(duration?:number):JQuery {
			var $ul:JQuery = $(&#x27;&lt;ul /&gt;&#x27;);
			var $li:JQuery;
			var i:number = 0;
			var l:number = this.length;
			for (; i &lt; l; i++) {
				$li = $(&#x27;&lt;li /&gt;&#x27;);
				$li.appendTo($ul);
			}
			var $lis = $ul.find(&#x27;li&#x27;);
			this.on(PsycleEvent.PANEL_CHANGE_END, (e:PsyborgEvent) =&gt; {
				$lis.removeClass(this._config.currentClass);
				$lis.eq(e.data.index).addClass(this._config.currentClass);
			});
			$lis.eq(this._config.startIndex).addClass(this._config.currentClass);
			$lis.on(&#x27;click&#x27;, (e:JQueryEventObject) =&gt; {
				this.gotoPanel($(e.target).index(), duration);
				e.preventDefault();
			});
			return $ul;
		}
		/**!
		 * マーカーを設定する
		 *
		 * @method marked
		 * @since 0.5.3
		 * @public
		 * @param {JQuery} $elem 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @param {Object} options オプション
		 * @return {JQuery} 生成したjQuery要素
		 */
		public marked ($elem: JQuery, options: any): void {
			var config: any = $.extend({
				type: &lt;string&gt; &#x27;li&#x27;,
				duration: &lt;number&gt; null
			});
			var type: string = &#x27;&#x27; + config.type;
			var nodeName: string = $elem[0].nodeName;
			var childTag: string;
			var $child: JQuery;
			var $children: JQuery;
			var i: number = 0;
			var l: number = this.length;

			if (nodeName === &#x27;UL&#x27; || nodeName === &#x27;OL&#x27;) {
				type = &#x27;li&#x27;;
			}

			switch (type.toLowerCase()) {
				case &#x27;li&#x27;:
				case &#x27;list&#x27;:
				case &#x27;ls&#x27;:
				case &#x27;ul&#x27;:
				case &#x27;ol&#x27;:
					childTag = &#x27;li&#x27;;
					break;
				case &#x27;i&#x27;:
				case &#x27;in&#x27;:
				case &#x27;inline&#x27;:
				case &#x27;span&#x27;:
					childTag = &#x27;span&#x27;;
					break;
				/*
				case &#x27;b&#x27;:
				case &#x27;block&#x27;:
				case &#x27;div&#x27;: */
				default:
					childTag = &#x27;div&#x27;;
			}
			$child = $(&#x27;&lt;&#x27; + childTag + &#x27; /&gt;&#x27;);

			for (; i &lt; l; i++) {
				$child.clone().appendTo($elem);
			}

			$children = $elem.find(&#x27;&gt;&#x27; + childTag);

			$children.eq(this._config.startIndex).addClass(this._config.currentClass);

			this.on(PsycleEvent.PANEL_CHANGE_END, (e: PsyborgEvent): void =&gt; {
				$children.removeClass(this._config.currentClass);
				$children.eq(e.data.index).addClass(this._config.currentClass);
			});

			$children.on(&#x27;click&#x27;, (e: JQueryEventObject) :void =&gt; {
				this.gotoPanel($(e.target).index(), config.duration);
				e.preventDefault();
			});
		}

		/**!
		 * コントローラをバインドする
		 *
		 * &#x60;prevClass&#x60; オプション 廃止予定
		 * &#x60;nextClass&#x60; オプション 廃止予定
		 *
		 * @method controller
		 * @since 0.4.3
		 * @public
		 * @param {JQuery} $elem バインドさせるjQuery要素
		 * @param {any} options オプション
		 */
		public controller ($elem: JQuery, options: any): void {
			var config: any = $.extend({
				prevClass: &lt;string&gt; &#x27;prev&#x27;,
				nextClass: &lt;string&gt; &#x27;next&#x27;,
				prev: &lt;string&gt; null,
				next: &lt;string&gt; null,
				duration: &lt;number&gt; null
			}, options);
			var prev: string = config.prev || (&#x27;.&#x27; + config.prevClass);
			var next: string = config.next || (&#x27;.&#x27; + config.nextClass);
			$elem.on(&#x27;click&#x27;, prev, (e: JQueryEventObject): void =&gt; {
				this.prev(config.duration);
				e.preventDefault();
			});
			$elem.on(&#x27;click&#x27;, next, (e: JQueryEventObject): void =&gt; {
				this.next(config.duration);
				e.preventDefault();
			});
			return;
		}

		/**!
		 * コントローラをバインドする
		 * &#x60;controller&#x60;のエイリアス
		 *
		 * @method ctrl
		 * @since 0.5.3
		 * @public
		 * @param {JQuery} $elem バインドさせるjQuery要素
		 * @param {any} options オプション
		 * @return {JQuery} 生成したjQuery要素
		 */
		public ctrl ($elem: JQuery, options: any): void {
			this.controller($elem, options);
		}

		/**!
		 * 指定の番号のパネルへ遷移する
		 *
		 * @method _transitionTo
		 * @since 0.4.2
		 * @deprecated
		 * @private
		 * @param {number} to 遷移させるパネル番号
		 * @param {number} [duration] 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @param {number} [direction=0] 方向
		 * @return {Psycle} 自身のインスタンス
		 */
		private _transitionTo (to:number, duration?:number, direction:number = 0):Psycle {
			return this.transitionTo(to, duration, direction)
		}

		/**!
		 * 指定の番号のパネルへ遷移する
		 *
		 * @method transitionTo
		 * @since 0.6.0
		 * @private
		 * @param {number} to 遷移させるパネル番号
		 * @param {number} [duration] 任意のアニメーション時間 省略すると自動再生時と同じ時間になる
		 * @param {number} [direction=0] 方向
		 * @return {Psycle} 自身のインスタンス
		 */
		public transitionTo (to:number, duration?:number, direction:number = 0):Psycle {
			this.isTransition = true;
			this.duration = duration;
			this.progressIndex = to;
			this.vector = this._optimizeVector(to, direction);
			this.from = this.index;
			this.to = this._optimizeCounter(this.index + this.vector);
			this.stop;
			this._before();
			this._fire();
			// アニメーションが完了したとき
			this.animation.done(() =&gt; {
				this._done();
			});
			// アニメーションが強制的にストップしたとき
			this.animation.fail(() =&gt; {
				this._fail();
			});
			return this;
		}

		/**!
		 * 番号の変化量の正規化
		 * 一番近いパネルまでの距離(パネル数)を算出する
		 *
		 * @method _optimizeVector
		 * @since 0.3.0
		 * @private
		 * @param {number} to 目的のパネル番号
		 * @return {number} 正規化された変化量
		 */
		private _optimizeVector (to:number, direction:number = 0):number {
			var vector:number;
			var dist:number = Math.abs(this.index - to);
			if (this.repeat === PsycleRepeat.LOOP) {
				vector = Util.getloopSeriesVector(this.index, to, direction, this.length);
			} else {
				vector = dist * ((this.index &lt; to) ? 1 : -1);
			}
			return vector;
		}

		/**!
		 * パネル番号の正規化
		 *
		 * @method _optimizeCounter
		 * @since 0.1.0
		 * @private
		 * @param {number} index 正規化するパネル番号
		 * @return {number} 正規化されたパネル番号
		 */
		private _optimizeCounter (index:number):number {
			var maxIndex:number = this.length - 1;
			var optIndex:number;
			switch (this.repeat) {
				case PsycleRepeat.LOOP:
				case PsycleRepeat.RETURN:
					optIndex = Util.getloopSeriesNumber(index, this.length);
					break;
				default:
					optIndex = (index &lt; 0) ? 0 : index;
					optIndex = (optIndex &lt; maxIndex) ? optIndex : maxIndex;
					if (this._isFirst(optIndex) || this._isLast(optIndex)) {
						this.stop();
					}
			}
			return optIndex;
		}

		/**!
		 * 指定したパネル番号が最初のパネルかどうか
		 *
		 * @method _isFirst
		 * @since 0.3.0
		 * @private
		 * @param {number} index 評価するパネル番号
		 * @return {boolean} 最初のパネルなら&#x60;true&#x60;
		 */
		private _isFirst (index:number):boolean {
			return index === 0;
		}

		/**!
		 * 指定したパネル番号が最後のパネルかどうか
		 *
		 * @method _isLast
		 * @since 0.3.0
		 * @private
		 * @param {number} index 評価するパネル番号
		 * @return {boolean} 最後のパネルなら&#x60;true&#x60;
		 */
		private _isLast (index:number):boolean {
			return index === this.length - 1;
		}

		/**!
		 * リサイズイベントを関連付ける
		 *
		 * @method _resizeable
		 * @since 0.1.0
		 * @private
		 */
		private _resizeable ():void {
			var resizeEndDelay:number = 300;
			var resizeTimer:number;
			var resizing:boolean = false;
			$(window).on(&#x27;resize&#x27;, (e:JQueryEventObject) =&gt; {
				if (!resizing) {
					resizing = true;
					this._resizeStart();
				}
				clearTimeout(resizeTimer);
				this._resize();
				resizeTimer = setTimeout(() =&gt; {
					this._resizeEnd();
					resizing = false;
				}, resizeEndDelay);
			});
		}

		/**!
		 * 現在の状態の情報を返す
		 *
		 * @method _getState
		 * @since 0.1.0
		 * @private
		 */
		private _getState ():IPsycleState {
			return &lt;IPsycleState&gt;{
				index:&lt;number&gt; this.index,
				stage:&lt;PsycleStage&gt; this.stage,
				container:&lt;PsycleContainer&gt; this.container,
				panels:&lt;PsyclePanelList&gt; this.panels,
				stageWidth:&lt;number&gt; this.stageWidth,
				panelWidth:&lt;number&gt; this.panelWidth,
				length:&lt;number&gt; this.length,
				from:&lt;number&gt; this.from,
				to:&lt;number&gt; this.to,
				vector:&lt;number&gt; this.vector,
				isTransition:&lt;boolean&gt; this.isTransition,
				isPaused:&lt;boolean&gt; this.isPaused
			};
		}

		/**!
		 * パネル内の画像の読み込みが完了した時
		 *
		 * @method _load
		 * @since 0.5.1
		 * @private
		 */
		private _load ():void {
			this.transition.reflow.call(this, { timing: PsycleReflowTiming.LOAD });
		}

		/**!
		 * 初期化処理を実行する
		 *
		 * @method _init
		 * @since 0.1.0
		 * @private
		 */
		private _init ():void {
			this.transition.init.call(this);
			this.transition.reflow.call(this, { timing: PsycleReflowTiming.INIT });
			this.trigger(PsycleEvent.INIT, this._getState());
		}

		/**!
		 * 非遷移番号移動を実行する
		 *
		 * @method _silent
		 * @since 0.1.0
		 * @private
		 */
		private _silent ():void {
			this.transition.silent.call(this);
			this.transition.reflow.call(this, { timing: PsycleReflowTiming.TRANSITION_END });
			this.panels.setCurrent(this.index, this._config.currentClass);
		}

		/**!
		 * 遷移直前の処理を実行する
		 *
		 * @method _before
		 * @deprecated
		 * @since 0.1.0
		 * @private
		 */
		private _before ():void {
			this.before();
		}

		/**!
		 * 遷移直前の処理を実行する
		 *
		 * @method before
		 * @since 0.6.0
		 * @public
		 */
		public before ():void {
			this.transition.before.call(this);
			this.panels.resetCurrent(this._config.currentClass);
			this.trigger(PsycleEvent.PANEL_CHANGE_START, this._getState());
		}

		/**!
		 * 遷移時の処理を実行する
		 *
		 * @method _fire
		 * @since 0.1.0
		 * @private
		 */
		private _fire ():void {
			this.transition.fire.call(this);
		}

		/**!
		 * 遷移キャンセル時の処理を実行する
		 *
		 * @method _cancel
		 * @since 0.1.0
		 * @private
		 */
		private _cancel ():void {
			this.transition.cancel.call(this);
		}

		/**!
		 * 遷移完了時コールバック関数
		 *
		 * @method _done
		 * @since 0.1.0
		 * @private
		 */
		private _done ():void {
			this.index = this.to;
			this.isTransition = false;
			this._after();
			this._silent();
			this.trigger(PsycleEvent.PANEL_CHANGE_END, this._getState());
			// 自動再生状態なら再生開始する
			if (this._config.auto) {
				this.play();
			}
		}

		/**!
		 * 遷移後の処理を実行する
		 *
		 * @method _after
		 * @since 0.1.0
		 * @private
		 */
		private _after ():void {
			this.transition.after.call(this);
		}

		/**!
		 * 遷移未完了で停止した場合のコールバック関数
		 *
		 * @method _fail
		 * @since 0.1.0
		 * @private
		 */
		private _fail ():void {
			this.stop();
			this._cancel();
			this.isTransition = false;
			this.trigger(PsycleEvent.PANEL_CHANGE_CANCEL, this._getState());
		}

		/**!
		 * リサイズ中の処理を実行する
		 *
		 * @method _resize
		 * @since 0.1.0
		 * @private
		 */
		private _resize ():void {
			this.transition.reflow.call(this, { timing: PsycleReflowTiming.RESIZE });
		}

		/**!
		 * リサイズ開始時の処理を実行する
		 *
		 * @method _resizeStart
		 * @since 0.1.0
		 * @private
		 */
		private _resizeStart ():void {
			this.transition.reflow.call(this, { timing: PsycleReflowTiming.RESIZE_START });
			if (this.animation &amp;&amp; this.isTransition) {
				this.freeze();
			}
		}

		/**!
		 * リサイズ終了時の処理を実行する
		 *
		 * @method _resizeEnd
		 * @since 0.1.0
		 * @private
		 */
		private _resizeEnd ():void {
			this.transition.reflow.call(this, { timing: PsycleReflowTiming.RESIZE_END });
			if (this.isPaused &amp;&amp; this._config.auto) {
				this.gotoPanel(this.to);
			}
		}

	}

}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
